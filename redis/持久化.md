# 持久化
首先要先明白一下为什么一个内存型数据库要做持久化，其实还是为了扩大redis的应用场景而生的需求。
redis的持久化其实是面试场景必考的内容了，但是很多时候想要细致的了解redis持久化还是不容易，本章
就主要描写一下redis的持久化策略和具体实现的方案。

## 目录
- [持久化种类](###持久化种类)
   - [AOF](###AOF)
        - [1.Aof 写日志的先后顺序](###1.Aof写日志的先后顺序)
        - [2.Aof 写日志的先后顺序的优缺点](###2.aof写日志的先后顺序的优缺点)
        - [3.Aof的三种配置策略](###2.Aof的三种配置策略)
        - [4.Aof的重写机制](###4.aof的重写机制)
        - [5.redis的fork函数](###5.redis的fork函数)
        - [6.Huge page带来的影响](####6.Huge page带来的影响)
        - [7.Aof文件是不被重用的](####7.Aof文件是不被重用的)
        - [8.Aof重写触发条件](###8.Aof重写触发条件)
   - [RDB](###RDB)
        - [触发方式](###触发方式)
        - [bgsave原理](###bgsave原理)



### 持久化方案
在redis中支持两种持久化方案
- Aof append only file ：追加写方案 类似mysql的redolog
- Rdb redis database : redis 数据库快照方案


## AOF

#### 1.aof写日志的先后顺序
提到aof方案，我们要清楚一点，aof是通过日志方式记录所有的redis写操作，但是这里需要注意的是
aof和mysql的redolog 实际上是不同的，mysql 的redolog 是wal ：write ahead log ，就是写
前日志，而redis就是写后日志。

为什么这么设计呢？

和mysql 不同的是redis 没有sql预处理器，在mysql 执行sql 阶段如果说语句报错了，那么在sql预处理
的时候就会被发现，在redis上没有sql预处理器或者类似的东西，那么只有实际的redis执行器，如果执行报错
那么这条语句肯定就是错的，也不用记录日志了，所以这样的方法减少了语句校验的麻烦。

#### 2.aof写日志的先后顺序的优缺点
后写日志存在的优点
- 直接省略语句校验的这部分编码实现
- 避免了直接写磁盘导致的性能损耗

带来的考虑

- 宕机丢数据风险，如果存在刚写入数据还没写log的时候宕机了，那么数据就被丢失了
- 虽然本次没有写磁盘操作，那么磁盘总归是要写的（也是主线程），那么可能阻塞一下次的操作

#### 2.aof的三种配置策略
redis的配置参数中存在一个配置项：appendfsync，有三个可选项
- Always : 每次都写入都同步记录到磁盘，性能很低
- Everysec ： 每秒进行刷盘，写入操作是同步到redis buffer，每秒写入到redis磁盘
- No： 由操作系统决定什么时候将缓冲区写入磁盘

#### 4.aof的重写机制

- 如何重写？

比如 set a 1 ,这个命令，我执行1000遍，对于aof来说是1000条数据，那么其实它只需要存一条数据
就是可以满足需求的，但是花费了1000个空间，所以这就是一个浪费，重写主要就是优化这样一个点，删除
掉没有用的重复的内容。

- 是否阻塞主线程？

在redis中但凡涉及到数据的写入，刷盘 比如flush buffer 这种都是主线程操作的，但是aof的重写机制
并不是在主线程中的，而是在一个bgrewriteaof 的子进程中。每次进行重写的时候就fork 一个子进程同时
fork会把主线程的内存进行拷贝给子进程

#### 5.redis的fork函数
在上面我们说到过fork子进程其实是一笔带过，但是fork子进程是伴随而来的是拷贝空间，fork这一个瞬间一定
是会被阻塞的，fork 的时候会调用系统的copy on write 就是为了避免一次性拷贝带来的长时间阻塞问题。
其实这个知识点应该属于c的内容了。

- fork函数子进程可以得到什么？
fork出来的子进程可以得到父进程的所有代码块
- fork 函数具体的优化点是什么？
子进程和父进程的虚拟地址是不同的，但是映射到物理内存是同一块地址，当两者共享数据发生改变的时候，内核
才会去分配真实内存空间。

上面讲了一下fork的原理，那么回到redis来说，fork 会把父进程的内存页表拷贝下来。所谓内存页表就是存放
虚拟内存和物理内存的映射索引表。这个拷贝会消耗大量cpu，当拷贝完成后子进程和父进程同时指向了相同的数据。

#### 6.Huge page带来的影响
在上面第五点讲到了fork完成后子进程和父进程同时指向了相同的数据，此时子进程可以开始重写aof了
- 将内存所有数据写入新的aof文件
- 当有新的流量写入，此时父子进程开始分离，父进程开始分配新的内存页，默认是4k，一旦此时操作的是bigkey，
那么就会出现一个问题：内存大页机制，页面大小为2M，所以在申请内存的时候阻塞几率会大大增加。

#### 7.Aof文件是不被重用的
在aof重写的过程中，子进程并不会重用aof文件，大致有两个原因

- 父子进程竞争问题
- 如果重写失败，防止污染数据

#### 8.Aof重写触发条件
什么时候会出发Aof的重写存在两个可能：
- auto-aof-rewrite-min-size： aof的最小大学校，默认为64MB
- auto-aof-rewrite-percentage: = 当前aof文件大小和上一次aof文件大小的差值，除去上一次文件大小。

这就是两个aof重写的触发条件。

## RDB
rdb redis database ，使用aof作为数据恢复的时候是非常缓慢的，但是使用rdb确是非常快速的，那么我们从底层看看为什么
rdb有这样的魔力。

#### 1.触发方式
- 手动配置 save m n ：表示在m秒内存在n个内容发生变化就触发rdb
- save ： 主线程进行save
- bgsave ：fork子线程进行save

这里便于理解
````
def SAVE():
    rdbSave()
def BGSAVE():
    pid = fork()
    if pid == 0:
        # 子进程保存 RDB
        rdbSave()
    elif pid > 0:
        # 父进程继续处理请求，并等待子进程的完成信号
        handle_request()
    else:
        # pid == -1
        # 处理 fork 错误
        handle_fork_error()
````

#### bgsave 原理
其实很多人都会想到，我一下保存这么大的数据到磁盘会不会阻塞到主线程，其实不用担心，基本上所有的rdb 触发条件都是在异步执行的
除非你使用了save命令。但是bgsave 和bgrewriteaof其实是一个原理，那么它们碰到的问题也必然是相同的。所以你只需要看看上面的
aof的fork子进程哪里就行了，cow道理是相同的： 就是在写入的时候，父进程开辟新的内存页进行修改，但是rdb的子进程还是记录原来的
数据。




