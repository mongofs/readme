# 哈希表
哈希表的英文是hashtable，我们平常叫hash 表或者散列表。散列表是利用数组支持随机访问的特性，所以散列表是数组的一种扩展，由数组扩展演化而来。


## 目录
- [哈希函数](##哈希函数)
- [哈希冲突](##哈希冲突) 
    - [开放寻址法](###开放寻址法)
    - [链表法](###链表法)
    - [装载因子](###装载因子)
    - [扩容](###扩容)


#### 哈希函数
又称散列函数，顾名思义它是一个函数，是怎么样的一个函数呢，是可以将一个key转化成一个数组下表的函数，返回值成为散列值。
- 1. 散列函数计算的一个散列值应该是一个非负整数
- 2. 如果key 相同，那么hash（key）必须一样
- 3. 如果key 不相同，hash（key）必须不一样

其实重点在于第三点，由于散列表的空间问题，几乎不可能存在一个散列函数可以满足第三点。举个例子，就算是md5、sha、crc 等工业著名函数也不能完成第三点，而且结合散列表大小和散列函数性质： 我散列表有100个位置，范围是[0,99],你散列函数出来的值肯定不应该大于或者小于这个范围，但是我需要装载的key 有101个，必然存在两个值会经过hash出现冲突。

#### 哈希冲突
从上面的哈希函数可以看出来我们几乎无法找到一个完全解决冲突的一个哈希函数，所以只能从哈希表上去解决这样的问题。

#### 哈希冲突解决办法：开放寻址法
开放寻址法就是如果出现了hash冲突，我们就重新探测一个空闲位置，将其插入。那么如何重新探测这个位置呢？

1. 线性探测。

 - 插入： 如果插入key的值已经存在，那么向后继续查找第一个为空的地址，放入里面。
- 查找： 和插入类似，如果hash的key的位置中数据对比不相同，向后遍历，直到不为空
- 删除：如果删除某个值需要将这个值进行标记deleted。查找的时候碰到某个空位是deleted 也要继续向下遍历。

2. 二次探测

什么是二次探测，二次探测和线性探测相似，只不过是线性探测步长为1，而二次探测每次的步长为 n方，比如第一次是1，第二次是4，第三次是9.

- 插入： 如果key值已经存在，那么向后1、4、9、16的查找空位，存在空位则放入里面
- 查找，如果key值已经存在，向后查找1、4、9、16... 查找位置比较，直到位置不为空。
- 删除：和线性探测是一样的，因为插入和查找都需要向后进行取值，我们如果存在某个位置x，第一次探测是有值，然后被删除了，第二次探测是没有值。那么如果这样继续探测下去，我们存放的值在当前hash key的9位，我们后面读值和取值可能都在第4位的基础，导致数据错乱。

3. 多重散列

重复hash方法也是开放寻址法的一种，是用一系列的hash方法进行hash存值，具体步骤就是当我获取到一个 key1 的时候 我经过第一次hash1（value1） 发现这个值已经存在且和我当前key1对应的值不相同，就使用hash2(value1)

- 插入 ：当发现key已存在，使用hash2（value）获取到key2值，依次类推
- 查找：和插入类似，我们按照对应的hash方法的顺序去进行查找
- 删除： 删除相比较之前的标记就要轻松一些了，因为我们多重散列是基于对比，换句话说，使用多重散列就相当于默认了hash（key1）=hash（key2），所以删除就可以直接删除，不需要标记。

#### 哈希冲突解决办法：链表法

相比较之前的开放寻址法，链表法是更加常用一点的解决hash冲突的方案。我们在数组中存放的一般都是指向链表的指针。当产生冲突，冲突key上的值就是一条链表。

- 插入：直接添加到冲突节点的链表尾部
- 查找：直接查找到对应节点，遍历节点进行对比
- 删除：直接删除链表上对应的节点。

#### 装载因子
什么是装载因子，装载因子是表示散列表中的空位多少的一个指标，很多散列表也是根据这个作为一个指标来进行散列表的扩容和缩容的。

- 装载因子= 个数/长度

装载因子越大，说明空闲位置越少，散列表性能下降。在golang的map实现中其实主要的就是使用的链表法+扩容的方式实现散列表。一般建议装载因子为0.8的时候进行扩容

#### 扩容
一般来说装载因子在0.8 的时候进行散列表的扩容，那么具体扩容的方案是怎么样的呢，
- 方案一：全部重新hash：在触发扩容的时候全部进行hash
- 方案二：被访问的时候进行回写。

一般来说我们更倾向于方案二，在进行读取的时候进行顺序写回，因为hash表的应用场景，所以如果说进行一次性rehash的话时间的代价太大，长尾时延导致用户的体验是非常差的。

#### 工业级的散列表
接下来我介绍一下工业级的Hash表的特性
- 装载因子0.75 ，扩容是二倍扩容
- 散列函数尽可能要简单，数据分配尽可能要均匀
- 性能要均衡，在极端情况下也要保证api不退化