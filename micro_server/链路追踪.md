#分布式系统链路追踪

当前分布式系统链路追踪根据推特官方开源的插件zipkin进行讲解

[zipkin](github.com/openzipkin/zipkin-go)


##目录
- [概念讲解](##概念讲解)
    - [OpenTracing](##Opentracing)
    - [Trace](##Trace)
    - [Span](##Span)
    - [SpanContext](##SpanContext)
    - [Baggage Items](##Baggage Items)
- [使用说明](##使用说明)

##Opentracing
OpenTracing 通过提供平台无关、厂商无关的API，使得开发人员能够方便的添加（或更换）追踪系统的实现
不过 OpenTracing 并不是标准。因为 CNCF 不是官方标准机构，但是它的目标是致力为分布式追踪创建更
标准的API 和工具

###Trace
一个 trace 代表了一个事务或者流程在（分布式）系统中的执行过程
###Span
一个 span 代表在分布式系统中完成的单个工作单元。也包含其他 span 的 “引用”，这允许将多个 spans 组合成一个完整的 Trace
每个 span 根据 OpenTracing 规范封装以下内容：

- 操作名称
- 开始时间和结束时间
- key:value span Tags
- key:value span Logs
- SpanContext

###SpanContext
SpanContext 代表跨越进程边界，传递到子级 Span 的状态。常在追踪示意图中创建上下文时使用

###Baggage Items
Baggage Items 可以理解为 trace 全局运行中额外传输的数据集合



##使用说明
我再官方包基础上加了一部分的代码，当然一下代码for循环中存在指针传递，i始终为最后一个，但是
我已经包之前测试代码删掉了，就将就这看吧。我们可以将trace作为资源放在我们的项目工程中

````
func main() {
	// create a reporter to be used by the tracer
	reporter := zipkinhttp.NewReporter("http://localhost:9411/api/v2/spans")
	defer reporter.Close()

	// set-up the local endpoint for our service
	endpoint, err := zipkin.NewEndpoint("demoService", "172.20.23.100:80")
	if err != nil {
		log.Fatalf("unable to create local endpoint: %+v\n", err)
	}
	// set-up our sampling strategy
	sampler, err := zipkin.NewBoundarySampler(0.01, time.Now().UnixNano())
	if err != nil {
		log.Fatalf("unable to create sampler: %+v\n", err)
	}
	// initialize the tracer
	tracer, err := zipkin.NewTracer(
		reporter,
		zipkin.WithLocalEndpoint(endpoint),
		zipkin.WithSampler(sampler),
	)
	if err != nil {
		log.Fatalf("unable to create tracer: %+v\n", err)
	}
	// tracer can now be used to create spans.
	for i:=0;i<10;i++ {
		go func() {
			name := fmt.Sprintf("some_operation_%v",i)
			span := tracer.StartSpan(name)
			time.Sleep(10*time.Millisecond)
			son := tracer.StartSpan("son_"+name,zipkin.Parent(span.Context()))
			time.Sleep(100*time.Millisecond)
			son.Finish()
			// ... do some work ...
			span.Finish()
		}()
	}
	time.Sleep(10*time.Second)
	// Output:
}
````


