# 上下文切换
cpu 在进行频繁的上下文切换会导致大量的cpu资源消耗，主要原因在于资源浪费在cpu切换的时候内容的保存和恢复上面，这个就是我们
常说的cpu上下文切换了。这章是比较重要的几个知识点。


## 目录
- [PC](###PC)
- [进程上下文切换](###进程上下文切换)
    - [进程内的系统调用](###进程内的系统调用)
    - [进程间的切换导致的系统调用](###进程间的切换导致的系统调用)
    - [进程上下文切换的触发条件](###进程上下文切换的触发条件)
- [线程上下文切换](###线程上下文切换)
    - [当线程是同属于一个进程](###当线程是同属于一个进程)
    - [当线程不是属于同一个进程](###当线程不是属于同一个进程)
- [中断](###中断)
### 上下文含义
我们首先要知道cpu在上下文切换到底保存的是哪些东西？ 我们通常称这些内容为：CPU寄存器以及程序计数器，简称Program Counter
又叫PC。用来存储指令位置，或者即将执行下一条指令位置。CPU 寄存器是CPU内置的容量小，速度快的内存。在cpu中 的寄存器就如同
电脑中的内存一样的。这两种内容共同组成了我们电脑的上下文，也就是我们程序运行所必须的环境


如果你是一个应用开发经验有一定年限的人，你可以这么去理解上下文切换：上下
文就是一堆某个请求必须的数据，cpu此时要处理其他请求，需要把你的内容暂时存到redis中，把别人的请求的数据读出来并执行，一定时间
或者触发条件后，cpu又要处理你的请求了，就需要把他们当前的内容存到redis中，把你的内容从redis读出来。
这里你可以理解为请求就是调度单位，cpu 还是cpu ，redis就是寄存器，存储的内容：

- 内核： 程序计数器、 内核堆栈等
- 进程： 虚拟内存、进程堆栈等内容


### 进程上下文切换
一般来说进程上下文切换是最耗费cpu资源的，比如我当前的进程有20个进程，但是我只有2核心来进行cpu操作，那么无疑就需要进行大量的
进程切换，就有我上面描述的
- 1.将当前进程的堆栈、虚拟内存等内容进行保存
- 2.将新的进程的堆栈，虚拟内存从寄存器中load出来

当需要保存的东西越多那么无疑你花费的资源也就越大。

#### 进程内的系统调用
其实我们在看进程切换的时候还会出现一种粒度比较细的上下文切换。 其实你大概知道了上下文切换是分为几种的，有进程上下文切换、线程
上下文切换、中断上下文切换。但是这几种是处于包含的状态，不一定说我进程上下文切换的时候一定是发生在独立于中断上下文切换的时刻。
接下来我们看一个进程内的上下文切换。

- 场景是我们再调用系统函数的时候：1.调用open 打开文件。2.调用read 将文件读到标准输出中。3.关闭文件。

我们简单分析一下这个系统函数调用会发送什么，首先要明确一点的是用户态的应用程序是没有资格去调用内核的东西，但是进程又可以处于
两个状态： 用户态、内核态，一般需要高级别权限的时候应用会升级到内核态运行。那么这中间的整体过程是怎么样的呢？
- 当程序调用系统函数的open 方法的时候，cpu 会保存当前用户态的运行内容，然后需要加载到内核态将文件进行打开就完成了打开这个
步骤，然后切换回用户态程序继续向下执行调用read 方法，cpu又切换回内核态调用read方法。。。

在这里你可以看到进程内的程序运行也是会发生上下文切换的。其实也佐证了我上面的观点，上下文切换并不是相互独立的
#### 进程间的切换导致的系统调用
首先你需要知道的点是：进程是由内核来进行管理调度的单元，进程的切换只会发生在内核态。进程的切换保存的内容不仅仅包括了虚拟内存、
栈、 全局变量等用户空间资源，还包括了内核堆栈、寄存器等内核空间状态。而且在最后还需要刷新进程的虚拟内存和用户栈。

- 1.保存当前进程的虚拟内存、用户栈
- 2.保存当前进程内核堆栈、寄存器
- 3.刷新进程的虚拟内存和用户栈


#### 进程上下文切换的触发条件
进程切换的时候才需要切换进程上下文，那么换句话说，只有在进程进行调度的时候才需要进行上下文切换。linux为每个cpu都维护了一个就绪
队列，将活跃的进程按照优先级和等待cpu的时间进行排序进行切换。当然这是正常的上下文切换

- 1.在上一个进程调度完成后，正常从就绪队列中获取一个新的进程进行运行
- 2.当前进程的资源不足，比如内存不够，当前进程就会被cpu进行挂起，从就绪队列中获取下一个进程运行
- 3.当进程调用sleep函数的时候，cpu就会将当前进程进行挂起
- 4.当存在更高优先级的进程运行，比如当前进程优先级为50，此时被排入一个优先级为80的进程，那么当前这个进程又会被挂起
- 5.发生中断的时候，当前优先级也会被挂起。

### 线程上下文切换
其实在理解线程上下文切换的时候，我们要着重理解一下线程和进程的关系，线程是调度最小单位，进程是资源的最小单位。内核调度进程的时候
其实就是在调度线程，而进程只是给线程提供了虚拟内存和全局变量等资源。

- 当进程只有一个线程的时候，可以认为进程等于线程
- 当进程拥有多个线程的时候，线程之间的切换，cpu其实并不需要保存进程的堆栈、虚拟内存，因为这两个线程是共享的
- 线程也是存在自己的私有的内容，比如栈、寄存器等内容，在上下文切换的时候也是需要保存的

#### 当线程是同属于一个进程
此时这里面的切换是不用保存虚拟内存的，只需要保存线程的私有数据，比如说：栈、寄存器等不共享内容。

#### 当线程不是属于同一个进程
此时可以当成进程之间来切换，我们可以通过多线程开发方式来代替多进程，这种模式对cpu切换的资源是可以得到性能上的提升的

### 中断切换上下文
中断是操作系统的一种快速响应硬件的临时操作，举个简单例子，如果说你当前一台机器很多人访问其中部署的web应用，但是同时
你这个机器又跑了很多循环脚本，刚好cpu负载为4（也标明你的cpu核心数量就是4），此时很多人访问你的web，那么cpu应该通过
怎么样的手段来进行监测网卡来的数据包呢？ 中断刚好就是这样的一个处理方式，在之前的cpu上下文切换的时候我在描述中断的时候
应该也讲到过，cpu当前的进程会被挂起（除非当前状态是不可中断：D），然后会去响应网卡将网络包load到内存中。但是load到内存
中过后呢？是继续管理load的包发到应用层？还是说继续之前被打断的进程？ 

之前我描述过中断是优先级最高的一种上下文切换，如果是当中断去响应网卡的包过后发送到应用层，那么就代表每个http请求就是优先级
最高的了，很显然不是这样的。那么如果说将包load到内存后继续之前被打断的进程吗？

其实这里还要提一个概念：软中断，一般来说我们说中断就是描述的硬中断，对硬中断的需求是快速响应并结束。还是那http web 应用
来讲的话，一个http包到网卡了内核肯定是要优先响应它，响应它的具体内容就是内核将网卡的包拿到内存中，然后继续之前的进程。然后
通过软中断，将内容包继续送到它应该去的位置。
