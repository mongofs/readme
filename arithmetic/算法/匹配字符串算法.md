### BF算法
brute force 算法，称为暴力匹配。这种算法原理非常简单，直接就是两个字符串进行对比，比如说
abcdefg 和 efg 做匹配，
- abc match efg
- bcd match efg
- cde match efg 

总共需要match len(abcdefg)- len(efg)+ 1 次比较。但是整体时间复杂度比较高： O(n*m), n 是原字符串
的数据，m 是比较字符串的长度，一般来说进行字符串对比实际上是


### RK 算法
这个算法是两个发明者的名字开头的算法，这个算法其实是在BF算法基础上进行的改进，改进的关键点在与： 字符串的对比
在上面的BF算法中总共要比较 n-m +1 次，每次比较时间复杂度为O(m),Rk的关键就是优化这个O(m)

- 具体做法是 hash主串的n-m+1 次，时间复杂度为O(n)
- 将模式串进行hash ，时间复杂度为O(1)
- 对比模式串的hash 是否存在主串hash集合中，时间复杂度为O(n)
- 由于是数值进行对比时间复杂度为O(1)

所以RK算法时间复杂度为2* O(n) =O(n)

- RK算法关键点在与哈希函数，和散列冲突
    - 哈希函数，所得到的值要是一个数字。比如我要比较abcdefg 和efg ，那么如何转换，第一个思路可以转换成
    26进制，比如abc = a* 26*26 +b *26 +c * 1 = 0 * 26 *26 + 1* 26 + 2 = 28 代表abc 是28.同理将
    efg 转化一下然后进行对比。
    - 哈希冲突，你可能看到了上面存在一个问题，abc =bc 那么出现冲突的时候我们又要回归到原始的对比算法上面去，就是
    遍历两个字符串进行对比。此时如果出现大量哈希冲突的时候可能出现O(n*m) 的时间复杂度
    
    
    
 ### BM算法
 BM算法实际上不是很容易理解，主要难点就在于什么是坏字符什么是好后缀。说起来是比较容易但是确实做起来还是比较难的，
 首先理解一下坏字符
 - 坏字符：倒叙从右到左开始数模式串的字符

 坏字符一定要好好的理解一下，我们在做BM算法的时候，我们通常把每次的模式串和主串上对应的内容相对应进行比较，那么每次
 比较的位置在模式串尾部对应的主串上的字符就称为坏字符。
 
 - 坏字符如果不存在模式串中，就把模式串整体后移一个模式串的偏移
 - 坏字符如果存在模式串中，就把右边第一个模式串与坏字符对应的进行对齐。原理是如果使用左边开始进行对齐的话必然会遗漏掉
 一部分的字符。
 
