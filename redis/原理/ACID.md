# ACID
要确认一下redis是有事务的，但是这个事务真正是否具备事务特性，你就要自己判断了，redis声明自己可以提供事务支持，但是
要确认一下事务特性和应用场景。
首先要强调的是redis是否支持ACID ，其实先认清楚什么是ACID
- A :Atomicity 原子性 
- C :Consistency 一致性 
- I :Isolation 隔离性
- D :Durability 持久化

## 目录
- [如何实现事务](##如何实现事务)
    - [Atomicity](###Atomicity)
    - [Consistency](###Consistency)
    - [Isolation](###Isolation)
    - [Durability](###Durability)
- [redis-check-aof](####redis-check-aof)




#### 如何实现事务
- multi 开启事务
- exec  开启执行
- discard 放弃事务

整体流程是首先和mysql的事务一样，开启事务，然后将所有事务放入一个队列中，在开启exec的时候统一执行。


####  Atomicity
关于原子性。其实原子性本身在redis中是难以被保证的，为什么这么说

- 情况一： 语句错误 。如果redis的事务中存在语句错误，ABC三条语句操作三个不同的东西，如果B语句为错误语句在
编译阶段就能被识别，那么在执行exec的时候就会报出错误，所有语句都错误。但是这种情况很少

- 情况二： 类型不匹配，如果redis语句没有错误，只是操作对象不匹配，比如pop 一个字符串，那么还是会执行，但是到
执行阶段，在它之前的内容都会被执行，到它这里的就会报错，但是原子性不被保障了。

#### Consistency
关于一致性，由于redis本身没有什么强约束关系，比如主键、外键约束，那么在任意时刻redis数据都是拥有一致性的。但是
比如我执行一个事务ABCD，当执行AB的时候redis死掉了，CD并没有执行其实也是符合数据库层面的一致性，只是不符合业务逻辑
的一致性了。

简单讲述完了这个原理的话，其实不论redis怎么样来进行操作都是保障了一致性的需求，因为它本身没有强约束的内容。


#### Isolation
隔离性的描述是怎么样的呢，就是执行事务的内容遇到并发操作的时候能否保证数据不被其他访问影响。但是实际上我们的事务存在两个
阶段：multi and exec 这两个阶段。其实在真正描述之前我想用简短的语言带你思考一下。我们知道redis在实际执行的阶段就是
单线程模型，单线程模型我们如何进行隔离呢，如果要实现真正意义上的隔离那么就是要加读写锁，可能你一听：单线程、读写锁，什么
鬼？ 既然是单线程为啥要加读写锁，直接就hang住其他的请求撒就实现了内容的隔离了，对于高性能的redis来说肯定不能采用这个方式
呀。所以其实对于单线程的设计模式和难有隔离性的保障。
但是呢，redis 存在一个watch 机制，就是标记一下元数据，之前不是说redisObject 的元数据。

- 在exec 命令之前使用一个watch 命令可以达到监管key变化的目的，否则无法保障。 watch 机制就是将数据监管，如果在watch的
连接触发的时间，其他的连接执行操作监管线程内的内容，那么exec 整体就会失败。
- 在exec 命令执行时候，因为是单线程，又是一个打包执行，所以这个时刻exec执行是原子的。


#### Durability
持久性，之前讲过redis的持久化所以这里不再赘述，不管怎么样事务的持久化是得不到保障的。

#### 总结
 - 原子性： 不支持
 - 一致性： 支持，没有强约束，任意时刻都是一致的
 - 隔离性：支持，但是需要额外的监控语句
 - 持久化：不支持
 
 
 ## redis-check-aof
 
 redis-check-aof 是在宕机后恢复数据需要的工具，在上面我们分析了一些情况得到了一个"不支支不"的一个结果，那么其实我们在构思场景的时候还遗忘掉了
 一个特殊情况：宕机。宕机为什么特殊，我们先讲讲案例。如果此时宕机了怎么办，这种情况我们一般只分析exec就好了，我们还是再过一遍redis的内容。
先执行multi 然后执行exec ，multi会将所有的命令存入redis待执行队列中，可以通过反馈值看待，queued。 此时用aof
其实已经将内容缓存，但是内容不知道缓存完没有：因为aof如果不选择always 就无法保障数据完全的安全。那么在做数据恢复
的时候我们使用了：redis-check-aof ，这个工具会将事务已经执行部分全部回滚



