
- 1.3 版本的GC ：只将程序的对象分为可达或者不可达对象，可达对象是指在程序中创建的对象以及对象引用的对象，以及对象创建的对象，
不可达对象指的是程序创建出来的对象被其他地方引用，这类不可达对象就会被标记出来清除掉，清除过程在STW中清除

- 标记、清除的缺点： stw 容易导致程序卡顿，2：标记需要扫描整个heap，每次扫描的内容比较大。3： 清除数据会产生heap碎片，导致内存不连续

之前的标记的STW 需要做的事情：
1. 启动STW 
2. 标记所有需要清除的地方
3. Sweep 清除
4. 停止STW

这里当时还进行优化了，因为第三步骤是一个On的复杂度的过程，所以这里采用的方法是渐进删除，将第三步骤提取出来，在停止STW后进行清除


 
### 三色标记
- write： 白色标记表标记白色节点
- grey ： 灰色标记表标记灰色节点
- black： 黑色标记表标记黑色节点

1. 期初所有节点都是白色节点，然后在GC的时候开始扫描程序的对象
2. 扫描的时候讲初始节点放到了灰色节点
3. for grey ！=nil {}
4. 如果碰到可达节点加入grey对象列表，这个节点标记为灰色
5. 回收所有白色节点

### 三色标记表没有STW的问题
在上面流程你会发现一个问题：没有STW ，那么会出现什么问题？
````
在程序的运行的过程中我们实际问题就是并发问题：在三色标记的问题上，我们期望的是能够在标记期间没有对象被创建出来，那么整体的
程序就是最简单的，但是在实际过程中我们标记了某个黑色节点如果创建出来了一个新的节点（初始颜色为白色），那么很显然在本轮标记
过程中这个节点就是属于未被扫描，但是依旧是白色，在回收阶段就会被误认为是没用节点而被回收


````
所以问题根源就是在没有stw的时候新增逻辑容易导致对象遗漏

- 白色对象被黑色对象引用
- 灰色对象与它可达对象的关系被破坏

这里有一个问题：就是三色标记法还需要维护一个灰色节点和它的子节点对象关系不被破坏，我目前还没搞懂这个问题

### 强弱三色不变式
强三色不变式：强制性的不允许黑色对象引用白色对象
弱三色不变式：黑色对象可以应用白色对象，但是白色对象存在其他的灰色或者上路可达线路存在灰色对象

### 插入写屏障
屏障的含义类似中间件一样，添加一些额外的判断逻辑。
 
 对象应用的时候被触发， 不管A对象是白色还是黑色，在A对象引用B对象的时候B对象被标记为灰色。值得注意的是插入屏障
 不在栈上使用。也就是说只有根节点在堆上的节点新建对象的时候，才会触发写屏障，如果根节点在栈上那么出现新插入节点
 怎进行处理呢？ 就是在启用一次stw，首先将栈上对象全部置为白色节点，扫描栈上的所有对象并再次进行标记
 
 不足的地方是：结束时候会STW从新扫描一下栈，大约需要10~100ms的时间

### 删除写屏障
被删除的对象如果自身为灰色或者白色，那么就被标记为灰色。主要用来保护灰色对象到白色对象的路径不会断开。相同的道理
如果说存在删除写屏障在栈上面也会被触发，因为和插入写屏障不一样，在删除写屏障的时候，可能如果不进行屏障处理，进行
STW的时候就容易丢失可达线路

不足的地方：一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中才被清理掉

所以插入写屏障和删除写屏障的时候，栈上对象存在删除写屏障而没有插入写屏障

### 混合写屏障
1. GC会将栈上的对象全部扫描标记为黑色： 之后不再重复扫描，无需STW
2. GC期间，栈上的所有的新对象都是黑色
3. 被删除的对象标记为灰色
4. 被添加的对象标记为灰色