### BF算法
brute force 算法，称为暴力匹配。这种算法原理非常简单，直接就是两个字符串进行对比，比如说
abcdefg 和 efg 做匹配，
- abc match efg
- bcd match efg
- cde match efg 

总共需要match len(abcdefg)- len(efg)+ 1 次比较。但是整体时间复杂度比较高： O(n*m), n 是原字符串
的数据，m 是比较字符串的长度，一般来说进行字符串对比实际上是


### RK 算法
这个算法是两个发明者的名字开头的算法，这个算法其实是在BF算法基础上进行的改进，改进的关键点在与： 字符串的对比
在上面的BF算法中总共要比较 n-m +1 次，每次比较时间复杂度为O(m),Rk的关键就是优化这个O(m)

- 具体做法是 hash主串的n-m+1 次，时间复杂度为O(n)
- 将模式串进行hash ，时间复杂度为O(1)
- 对比模式串的hash 是否存在主串hash集合中，时间复杂度为O(n)
- 由于是数值进行对比时间复杂度为O(1)

所以RK算法时间复杂度为2* O(n) =O(n)

- RK算法关键点在与哈希函数，和散列冲突
    - 哈希函数，所得到的值要是一个数字。比如我要比较abcdefg 和efg ，那么如何转换，第一个思路可以转换成
    26进制，比如abc = a* 26*26 +b *26 +c * 1 = 0 * 26 *26 + 1* 26 + 2 = 28 代表abc 是28.同理将
    efg 转化一下然后进行对比。
    - 哈希冲突，你可能看到了上面存在一个问题，abc =bc 那么出现冲突的时候我们又要回归到原始的对比算法上面去，就是
    遍历两个字符串进行对比。此时如果出现大量哈希冲突的时候可能出现O(n*m) 的时间复杂度
    
    
    
 ### BM算法
 BM算法实际上不是很容易理解，主要难点就在于什么是坏字符什么是好后缀。说起来是比较容易但是确实做起来还是比较难的，
 首先理解一下坏字符
 - 坏字符：倒叙从右到左开始数主串中不匹配的字符

坏字符需要好好理解一下，第一个点是倒叙，如果我们把abdefg 和abc进行排序的时候，一般来说那么比较的顺序是
先比较d和模式串的c，很明显两个字符不相同，那么我们把主串的字符d称为坏字符。此时有几种情况
 
 - 查找坏字符在模式串中是否存在
    - 坏字符在模式串中不存在，那么将模式串整个后移动m 个偏移量
    - 坏字符在模式串中存在一个，将模式串中的坏字符和主串坏字符对齐。
    - 坏字符在模式串中存在多个，将模式串中的最靠后的坏字符与主串对齐
 - 偏移对齐坏字符。
 
通过坏字符的比较，整体效率是非常高的：最好的时间复杂度可以达到O(n/m),但是坏字符存在局限性。比如说ccccc和acc
这个字符比较，就会出现一种现象在将坏字符对齐的时候，你会发现坏字符的位置比 模式串的坏字符位子要小，两者进行位移
计算的时候容易导致一个现象，模式串向后退。此时就要引入好后缀了。

好后缀是什么呢，举个上面说的例子ccccc 和 accc来说。模式串与主串中相同的部分我们称为好后缀，就是公共
部分ccc，那么把这块看成一个整体{ccc}，
 
 - 查找是否还存在好后缀，如果还存在，将好后缀进行对齐
 - 如果不存在其他的好后缀，检查好后缀的尾 和len（模式串的头）是否存在对应
    - 不存在对应直接将模式串后移m个位
    - 如果存在直接将模式串移动到头尾对齐位置。
    
如何选择坏字符和坏后缀进行数据处理。我们可以分别计算好后缀和坏字符移动的位数，然后进行移动，可以避免坏字符移动负数的
情况。


### KMP 算法
其实kmp 算法其实不太好理解，网上博文一大片还是理解起来比较生涩。KMP算法核心无非是在已经比较过的值上面加大一下
步长。

#### 核心原理
kmp核心原理：在对已经比较过的值上进行加大步长的操作，如何跳，跳多少？就是随之而来的问题了。PMT （Partial Match Table
中文翻译为部分比较表。pmt就是解决如何跳、跳多少的一个问题的关键算法。其中核心就是
````
步长 = 已经匹配的个数- 未匹配部分的第一位pmt值
````
举例：主串：abcaccabc，模式串：cab
-  abc 和cab 对比，a和c不相同，模式串后移一位，
- bca和cab 对比，b和c不相同，模式串后移一位
- cac和cab 对比，ca属于相同部分，上面公式已经匹配个数为2，未匹配的部分第一位就是b的pmt值为 0，整体后移2-0 
- cca 和cab 对比，c相同，c和a不同，a的pmt值为0，整体后移1-0
- cab 和cab 对比，相同则返回。

#### pmt值算法
- 前缀 ：除了字符串最后一位，都属于前缀
- 后缀：除了字符串第一位都属于后缀

计算 abca的每个值的pmt值

- a 的pmt ：0，因为a的前缀后缀都为空，交集为空
- b 的pmt : 0，实际计算的是ab ,总共存在前缀a， 后缀b,交集为空
- c 的pmt ：0，实际计算abc, 总共存在前缀：a,ab 后缀，c,bc,交集为空 
- d 的pmt : 1,实际计算abca,前缀：a,ab,abc, 后缀： a,ca,bca ，交集为 a