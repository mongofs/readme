# 四次挥手

一般我们描述四次挥手的时候需要记住为什么要四次挥手，四次挥手真的安全吗，四次挥手的状态机
以及四次挥手的可能出错的地方，那么你就完成了深入理解四次挥手

##目录

- [四次挥手的流程](###四次挥手的流程)
- [wireshark抓包为什么会出现三次挥手](###wireshark抓包为什么会出现三次挥手)
- [为什么需要等待两个MSL](###为什么需要等待两个MSL)
- [挥手发生还能传输内容吗](###挥手发生后还能传输内容吗)    
    
    
### 四次挥手的流程
我们回顾一下四次挥手的流程
1. 客户端发送 ：fin 包 ，进入fin_wait_1状态
2. 服务器发送： ack 包，进入close_wait ，客户端收到这个包后进入fin_wait_2状态
3. 服务端发送： fin 包，进入last_ack 
4. 客户端发送： ack 包，进入time_wait状态，服务器收到包后，进入closed 

值得注意的是：客户端进入time_wait状态后，需要等待两个msl ，一般来说这也是一个问题点
待会单独罗列出来描述一下


### wireshark抓包为什么会出现三次挥手
一般来说很多的包喜欢合并，也就是piggybacking 类似搭顺风车，所以当你看到存在某个tcp流的时候
我们可以往上多探几个包，比如post 请求中也可能带上fin包，或者说被断开方的fin包和ack包是同时
发回去的，所以不要轻易怀疑tcp的严谨，毕竟那么多前人使用过的东西

### 为什么需要两个MSL
首先需要理解一下什么是MSL ：maximum segment lifetime， 报文段在网络中最大的存活时间，每个
TCP实现都需要一个确定的MSL值，RFC 1122 建议是2分钟，这个和之前讲解的IP包的TTL的跳数量是相近
的一个概念。

1. 其实这里第一个原因是为了保证被断开方正常进入closed状态。 怎么理解？假设我们在客户端发送
ack后直接进入closed，直接省略掉time_wait，如果客户端发送最后一个ack后，这个ack包丢失，好
那么此时服务端就会认为我自己发送的fin包发送失败了，就会重发fin，但是客户端就无法响应了，此时
服务端就会卡在last_ack上。 

   那么按照正常逻辑的话，如果客户端发送最后一个ack包，中途丢包了，服务端就会重传这个最后的fin包，
   这里是很有意思的，是服务端重传fin包，而不是客户端重传ack包，因为客户端不保证最后一个包的到达
   ，最后一个包的到达是靠着服务端自己维持的。客户端收到第二个fin包会启动一个2msl的计时器，重新
   发送最后一个ack包。如果在2msl时间区间内，没有收到新的包，客户端就会进入closed

2. 第二个原因是保证网络上没有任何包了，如果某个包在网络上滞留了，在原本连接上被重发，且重发的包被
确认了，此时，这个包好像被遗弃的孤儿，原本连接没有它也正常进行，怪就怪在原本连接被释放了过后，新连接
被建立起来，这个包又跑回来了，此时新的连接就认识不了它了，就会导致新链接进入自我怀疑状态。

 
 ### 挥手发生后还能传输内容吗
 在常规场景我们已经见到了，这里会出现一个问题，挥手发生后还能传输内容吗？答案是可以的，这也是为什么
 需要四次挥手的一部分内容吧。
 假设一个场景：如果客户端发起了挥手，发出一个fin，但是此时如果说我们服务器还有东西在传输，此时是应该
 怎么样的呢？
 
 1. 客户端发送：fin ，表示我没东西要传了，我想断开了
 2. 服务端发送：ack ，好的，但是我这边还有东西要传
 3. 服务端发送：data1 ，data2
 4. 客户端回复：ack1、2
 5. 重复 。。。。。
 6. 服务端发送：fin ，表示我的东西也传完了，我们断开吧
 7. 客户端发送: ack ，进入time_wait
 
