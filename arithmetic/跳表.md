# 跳表
跳表，又称skipTable ,增加了向前指针的链表叫作跳表。跳表全称叫做跳跃表，简称跳表。跳表是一个随机化的数据结构，
实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索
引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。


## 目录
- [原理](###原理)
    - [索引层数](###索引层数)
    - [快速查找](###快速查找)
- [复杂度](###复杂度)
    - [时间复杂度](###时间复杂度)
    - [空间复杂度](###空间复杂度)
- [API](###API)
- [索引](###索引)
- [实战](###实战)
    - [基本结构](###基本结构)
        - [Node](###基本结构)
        - [List](###基本结构)
        - [index](###基本结构)

### 原理 
跳表是一种性能优秀的动态数据结构，支持快速的插入、删除、查找。其原理在于给链表加上多级索引
实现快速查找。

#### 索引层数
在理解索引工作原理后我们能获取到一个公式：
- n/2^h =2

如何理解呢，比如我有一个n个节点的链表，假设间隔为2抽一个索引出来，那么：一级索引就有n/2个节点，二级索引
就有n/4 个节点，递推下去第k层的节点个数：n/2^k。 通过公式倒推，我们有一个h级索引，间隔是2，最高级的索引
数量为2那么同理可以算的n/2^h = 2 ，带入换算h = log2n -1 (log2n 是2为底n的对数) 


#### 快速查找
快速查找原理就是通过高层遍历对比查找对应的值是在哪个索引之间、或者刚好踩中索引就直接返回了。

- 一级索引查找N

举个简单例子，我们知道在链表上进行随机查询时间复杂度为n ，假设我们目前有一个k个节点的链表，
我要查询第n个节点。那么需要遍历到第n个节点才能获取到节点n上的值。此时如果我存在一个一级索引
（索引跨度默认是2）从索引层开始遍历，我要获取到节点n存在两种情况：n是2的倍数 、 n是一个奇数
那么遍历节点数量变成： n/2 \ n/2 +1。 此时最坏情况就只需要遍历一半加一的节点就可以获取到
n的值。

- 二级索引查找N

同理，如果我使用的是二级索引查找N。那么此时：获取到节点n还是两种情况，n是2的倍数、n不是2的
倍数（其实就是看n在不在索引指向的节点上）。那么此时遍历节点数量 n/4+1 (遍历节点指的是需要对比
的节点，不包含中间节点)

```
    值得注意的是： 如果你深入的在思考，上面计算查询其实是有漏洞的： 每层次的索引查询应该是：
至少两次的，因为查找的是一个范围内的节点。比如说我查找节点1 ，那么在索引上我必须查找0，2 索引。
发现节点1在0之后，才会使用down指针去发现这个节点，除非索引0节点的后继指针是nil。
```