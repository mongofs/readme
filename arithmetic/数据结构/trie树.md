# Trie 树
trie树也称为字典树，就是一个树的结构的演变，trie树本质就是利用字符串公共前缀将重合的部分合并在一起。trie树的
作用相对比较有限，其实更多实际应用场景在trie树上就是存储、查找、删除字符串，而且时间是'O(n)',这里值得注意的是
这个n 并不是指树的节点n，而是查找数据的n，一般来说的话也可以把n理解为一个常量。


### 应用场景
为什么在有hash表、二叉平衡查找树这些高效的数据结构后还用trie树来进行存储、查找相关应用？确实，在散列表、红黑树高效
的面前trie树是没有什么优势的，几乎是忽略不计的，但是每个数据结构都是有相对应的应用场景。虽然我们可以使用trie树，但是
还是不建议使用它来进行普通字符以及对象存储。

- 优势： trie树的优势是联想相同的前缀节点，如果相同前缀的内容走过的前缀存储节点是相同的，由于这个特性，一个trie树
可以十分快速的查找到相同的前缀的关联词，比如百度搜索、google搜索的应用联想。

#### 缺点
一般来说trie树是空间换时间的标杆，我们在散列表中存储的内容一般是一个node存一个指向原地址的指针。简单来分析一下
我们要存储的是英文字符：
````
treeNode {
   Value int
    next map[rune]*treeNode
}
````
- 1.每个节点实例化都要申请26个容量的数组空间，那么什么都不用做我们就需要长度为26的数组空间
- 2.每个节点存储一般都是存储子节点指针，在64位上就是8字节，那么如果这个数组填满：26*8 =208字节
- 3.即使我们的节点存不了26个，我们依旧需要维护长度为26的数组


#### 优化
如果说trie树的优化的话，一般可以对节点优化，一般trie树节点是使用了数组进行存储，声明26长度的数组进行存储，
如果我们把存储由数组变成链表会不会更好一些呢，但是又回到了有一个问题上面来了，看你愿不愿意牺牲时间来换取空间