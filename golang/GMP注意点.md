#GMP 注意点
在之前说过很多关于调度相关的内容，说实话，调度其实真不是很麻烦，而且理解起来也是比较容易的一个环节
所以我也不再过多的去将什么GMP的对应关系，如何窃取，什么是hand off 等，这些感觉已经被市面上的博文
讲烂了，不用google，直接百度都有一堆一堆的内容，所以在这篇文章中主要还是讲解一些关于调度中比较关键
的几个知识点吧

- G0 和M0,首先M0 是启动程序后编号为0的主线程，在全局变量runtime.m0，不需要在heap上分配
负责执行和初始化第一个G，启动第一个G后M0就和其他的M一样了
- 每次启动一个M，都会创建一个goroutine ，就是G0，G0只用来调度，不指向任何的可执行函数，每个M
都会有自己到的G0,在一个Goroutine 完成执行被调度的时候，M会先切到G0，M0的G0也是全局变量的

- 创建一个G，因为所有程序都是在G中执行的，创建G肯定也是在G中，所以当一个G创建一个G1的时候，G1
会有限创建在G的本地队列中，当本地队列已经超过最大限度256，那么就会被放到全局队列。这里会存在一个点
就是当本地队列满了，会将队列前半部分50% 的Goroutine 和后面创建的groutine 打乱顺序放入全局队列

- 唤醒休眠的M： 在每次创建G的时候都会试图去唤醒一个M，M被唤醒的时候就会去找一个空闲的P，如果没有空闲的
P进行绑定，那么M就会将自己再次休眠，如果存在一个M被唤醒了过后绑定到空闲P，如果P中没有内容，那么就会变成
一个自旋线程
- 自选线程会优先从全局队列获取，获取个数是：min(len(gq)/gomaxprocs+1, len(gq)/2)
- 自选线程如果从全局队列没获取到内容就会使用stealing算法是获取到邻近的process的一半内容是后半部分到当前队列
- 自旋线程：被唤醒的M绑定到了一个P，但是P没有可执行的内容，此时就会进入一个自旋状态，称为自旋线程。自旋线程
是为了抢占goroutine的，
- 自旋线程 + 执行线程 < = gomaxprocs

- 当发生goroutine阻塞的时候，M和P就会分开，此时P就会优先去M的空闲队列中唤醒M进行绑定，如果空闲队列中没有了M
那么就会去创建一个M进行绑定

- 当GM 两个执行完阻塞操作，M优先会去找原来的P进行绑定，如果P是已经被另外一个M绑定，那么M会去P的空闲队列找
P，如果空闲队列没有的话，那么就将自己进行休眠


### Goroutine 的发展历程
其实看透Goroutine 也不过是协程的一种变体，一个进程对应多个线程，一个线程对应多个goroutine ，goroutine
和常说的coroutine是不太一样的，是go官方单独封装的一个内容，也是属于一个协程的范畴。为什么要做这么多的事情呢
其实更多的是提高程序的吞吐，通过减少cpu上下文切换的时候或者说上线文切换的成本，提高cpu利用率。