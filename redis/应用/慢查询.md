### 慢查询
redis之中还是有很多慢速操作的，之前我们也分析过相关的内容了，但是还是不够具体，不够系统。
那么我们今天来看看看redis的阻塞操作。

##目录
- [慢查询](###慢查询)
    - [客户端](###客户端)
        - [关于网络IO](#####关于网络IO)
        - [键值对操作](#####键值对操作)
    - [磁盘交互](###磁盘交互)
        - [生成RDB](###生成RDB)
        - [生成AOF](###生成AOF)
    - [主从节点](###主从节点)
    - [切片集群实例](###前片集群的迁移)
- [异步优化](####异步优化)

## 慢查询

#### 客户端
从客户端角度出发能有什么交互可以阻塞redis的主线程呢，我们就要列举出
- 网络IO
- 键值对的操作
- 数据库操作

##### 关于网络IO
客户端和redis的服务器的网络连接是基于tcp，之前有描述过tcp建立连接是基于socket的几个形态的转变
- 主动套接字： socket
- 监听套接字：listenling
- 已连接套接字：accepte 

redis网络IO是使用的多路复用的IO模型，在监听套接字、已连接套接字上面都不会出现阻塞问题，至于创建
socket其实一般来说客户端都是池化连接，所以每次建立连接后重新创建的几率都是比较小的，所以网路IO
阻塞可能性比较小。

##### 键值对操作
这个概念相对来说就比较泛了，如果是增删改查来说的话，
- 增： bigkey 
- 删： bigkey
- 改： 无
- 查： 范围查询等On操作

其实关于redis键值对操作来说的话，第一避免大key的操作，第二得分析一下时间复杂度，比如On复杂度下的操作
- 集合类型的全量查询
- 集合类型的聚合查询
- 范围查询： lrange ，zrange

还有一个点就是特殊的触发操作: flushDB flushALL等操作

#### 磁盘交互
磁盘是计算机中存储内容最大，但是写入数据是最慢的一个物件，一个同步写磁盘大概耗时是1~2ms，如果存在大量的
写磁盘操作，那么就容易导致主线程阻塞了。

- AOF 的同步写：always策略
- 主从同步导致的FlushDB，从库的策略是清空本地内容，清空这个过程就会导致从节点的主线程阻塞
- 主从同步加载RDB文件，在清空本地内容后加载到主节点，加载RDB文件就是将磁盘读入内存，也是在主线程完成

#### 主从节点

主从节点之间的内容也是比较容易阻塞主线程的，除了上面在磁盘交互出现的问题以外还有一些其他的，我全部罗列出来吧
- 主从同步生成RDB ，fork 函数copy父进程的内存空间，内存越大fork时间越久，master的主线程阻塞
- 主从同步，从节点flushdb ，从节点主线程阻塞
- 主从同步，从节点加载rdb，从节点主线程阻塞


#### 切片集群的迁移


## 异步优化
其实关于redis 的慢操作，统计出来就5个，还有部分是可以通过异步来防止阻塞主线程的操作。那么异步优化的原理是什么呢？
异步优化的原理关键在于redis的几个子线程分别负责redis的延时队列的任务：

- flushDB 和bigkey 的删除都可以在子线程操作
- 子线程异步aof同步写操作

## 如何操作
- 删除bigkey 的时候使用unlink 命令
- 清空数据库使用 flushDB async
- 使用everysec 代替always



