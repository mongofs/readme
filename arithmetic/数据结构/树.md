# 树
树：其实在数据结构中树只是和链表一样的内容，其实树还是比较好理解，就是和图需要分清楚，图中是存在环的，而树没有环
## 目录
- [树](##树)
    - [树的定义](###定义)
    - [树的三维](###三维)
    - [树的遍历](###遍历)
    - [树的存储](###树的存储)
    - [二叉树](###二叉树)

#### 树的三维
- 高度 （height）：树的高度底层从叶子节点数起，起始高度为0，根节点最高，节点高度就是当前节点到叶子节点的最长路径
- 深度（depth）：树的深度是从根节点数起，深度为0开始，根节点最低。节点深度就是当前节点到根节点的边数。
- 层次（level）：层计算和深度是保持一致，不同的是层从1开始，节点的层就是深度+1.

#### 树的存储
- 链式存储法: 链式存储法相对来说比较好理解一点，用链表来进行树的存储，每个节点存在几个属性： left、right、value，前两个分别存储左右子节点的指针。
- 顺序存储法：使用数组来进行链式的存储。问你一个问题，如果说我在树中不记录a节点的左右子节点的指针，那么如何进行a节点的左右指针查找？其实就是借着二叉树的特性：左节点比右节点小。具体操作就是把根节点地址放为1，那么根节点的左子节点为2，右子节点为3，那么2号节点的左子节点为4，右子节点为5，你其实可以画一下：你会发现：这样的排列方式下，左子节点的下标和父节点的下标是二倍关系，而右子节点的下标是：父节点*2+1 的关系。

#### 树的遍历
 - 前序遍历
 - 中序遍历
 - 后续遍历



 #### 二叉树
二叉树，每个节点拥有两个叉，分别是左子节点和右子节点，多叉树是很常用的数据结构，其中二叉树又是最常用的，由于其特性我们还可以衍生出很多其他的树的定义。

- 满二叉树 ： 除了叶子节点外所有节点都存在两个节点，铺满所有节点
- 完全二叉树： 最后一排节点按左边排列，中间不允许存在空隙。一般来说完全二叉树是用数组存储是最省内存的，因为不需要额外的左右指针的存储，在64位上就可以单个节点省下16字节的空间。


#### 二叉查找树
二叉查找树是二叉树的升级版本了，二叉查找树要求树中的每个节点的左子节点小于节点小于右子节点。保证节点之间的顺序性。

-  查找：
二叉查找树之查找：我们先从根节点上开始查找，如果查找的数据比当前节点小那么就查找左子树，如果查找的比当前节点大，那么就去右节点查找。

- 插入：
二叉查找树的插入和查找实际上是类似的，如果需要插入的数据比节点的数据大，并且节点的右子树为空那么就将新数据插入右子树，同理如果插入数据比节点数据小并且节点左子树为空，那么将新数据插入到左子节点位置；如果不为空在比例左子树找到位置插入

- 删除：删除操作相对来说比较复杂。
    - 情况一：如果要删除的节点没有子节点，我们只需要将父节点指向空
    - 情况二：如果要删除的节点只有一个子节点，只需要更新父节点的指针指向它的子节点。
    - 情况三：如果要删除的节点中有两个子节点，那么就可以找左子树的最大子节点或者右子树的最小子节点，替换当前节点

- 其他操作：除了插入、删除、查找这些操作之外，二叉查找树还能支持快速找到最大节点和最小节点、前驱节点、后继节点。除此之外我们还应该需要支持一个快速排序的功能，原理就是调用中序遍历，输出有序数据，时间复杂度是O(n).十分的有效。

- 支持重复数据的二叉查找树
    - 方法一： 链表法：和哈希表中的链表法相同，我不再赘述
    - 方法二： 多点存储，其实原理还是比较简单，就是我们在查找的时候，获取到了重复数据不要停止，直到获取到叶子节点为止。查找到的结果是一个key值相同的组合。同理删除也是先获取到所有的节点递归删除。


- 时间复杂度：从前面分析可以看出我们的时间复杂度其实和二叉树的高度相关，O(height)的复杂度。这里问题就从时间复杂度求树的高度了。如何求二叉查找树的高度呢？这样我们先求一下完全二叉树的相关属性：
    - 完全二叉树节点总数： n= 2^(k-1) ：k是层    

这里有一个问题你可能已经注意到了,我们上面的算法其实是满二叉树的算法，完全二叉树其实并不能排满最后一层，所以 n的大小： 2^(k-2)<n<2^(k-1).换算一下这个完全二叉树： log2(n+1)<k<log2n +1,这里我们计算的方法是使用的层，那么高度就必然小于等于 log2n.所以时间复杂度大概是logn。

这里为止我们大概直到了二叉查找树的一个性能，其实是非常不错的，但是在普通的应用场景中我们为什么直接用二叉查找树呢，主要原因在于二叉查找树在面临极端情况有可能导致二叉查找树变成链表。比如我顺序插入987654321，那么树就变成了一个链表。




