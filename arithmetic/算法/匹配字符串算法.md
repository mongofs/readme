### BF算法
brute force 算法，称为暴力匹配。这种算法原理非常简单，直接就是两个字符串进行对比，比如说
abcdefg 和 efg 做匹配，
- abc match efg
- bcd match efg
- cde match efg 

总共需要match len(abcdefg)- len(efg)+ 1 次比较。但是整体时间复杂度比较高： O(n*m), n 是原字符串
的数据，m 是比较字符串的长度，一般来说进行字符串对比实际上是


### RK 算法
这个算法是两个发明者的名字开头的算法，这个算法其实是在BF算法基础上进行的改进，改进的关键点在与： 字符串的对比
在上面的BF算法中总共要比较 n-m +1 次，每次比较时间复杂度为O(m),Rk的关键就是优化这个O(m)

- 具体做法是 hash主串的n-m+1 次，时间复杂度为O(n)
- 将模式串进行hash ，时间复杂度为O(1)
- 对比模式串的hash 是否存在主串hash集合中，时间复杂度为O(n)
- 由于是数值进行对比时间复杂度为O(1)

所以RK算法时间复杂度为2* O(n) =O(n)

- RK算法关键点在与哈希函数，和散列冲突
    - 哈希函数，所得到的值要是一个数字。比如我要比较abcdefg 和efg ，那么如何转换，第一个思路可以转换成
    26进制，比如abc = a* 26*26 +b *26 +c * 1 = 0 * 26 *26 + 1* 26 + 2 = 28 代表abc 是28.同理将
    efg 转化一下然后进行对比。
    - 哈希冲突，你可能看到了上面存在一个问题，abc =bc 那么出现冲突的时候我们又要回归到原始的对比算法上面去，就是
    遍历两个字符串进行对比。此时如果出现大量哈希冲突的时候可能出现O(n*m) 的时间复杂度
    
    
    
 ### BM算法
 BMsufan1