### BF算法
brute force 算法，称为暴力匹配。这种算法原理非常简单，直接就是两个字符串进行对比，比如说
abcdefg 和 efg 做匹配，
- abc match efg
- bcd match efg
- cde match efg 

总共需要match len(abcdefg)- len(efg)+ 1 次比较。但是整体时间复杂度比较高： O(n*m), n 是原字符串
的数据，m 是比较字符串的长度，一般来说进行字符串对比实际上是


### RK 算法
这个算法是两个发明者的名字开头的算法，这个算法其实是在BF算法基础上进行的改进，改进的关键点在与： 字符串的对比
在上面的BF算法中总共要比较 n-m +1 次，每次比较时间复杂度为O(m),Rk的关键就是优化这个O(m)

- 具体做法是 hash主串的n-m+1 次，时间复杂度为O(n)
- 将模式串进行hash ，时间复杂度为O(1)
- 对比模式串的hash 是否存在主串hash集合中，时间复杂度为O(n)
- 由于是数值进行对比时间复杂度为O(1)

所以RK算法时间复杂度为2* O(n) =O(n)

- RK算法关键点在与哈希函数，和散列冲突
    - 哈希函数，所得到的值要是一个数字。比如我要比较abcdefg 和efg ，那么如何转换，第一个思路可以转换成
    26进制，比如abc = a* 26*26 +b *26 +c * 1 = 0 * 26 *26 + 1* 26 + 2 = 28 代表abc 是28.同理将
    efg 转化一下然后进行对比。
    - 哈希冲突，你可能看到了上面存在一个问题，abc =bc 那么出现冲突的时候我们又要回归到原始的对比算法上面去，就是
    遍历两个字符串进行对比。此时如果出现大量哈希冲突的时候可能出现O(n*m) 的时间复杂度
    
    
    
 ### BM算法
 BM算法实际上不是很容易理解，主要难点就在于什么是坏字符什么是好后缀。说起来是比较容易但是确实做起来还是比较难的，
 首先理解一下坏字符
 - 坏字符：倒叙从右到左开始数主串中不匹配的字符

坏字符需要好好理解一下，第一个点是倒叙，如果我们把abdefg 和abc进行排序的时候，一般来说那么比较的顺序是
先比较d和模式串的c，很明显两个字符不相同，那么我们把主串的字符d称为坏字符。此时有几种情况
 
 - 查找坏字符在模式串中是否存在
    - 坏字符在模式串中不存在，那么将模式串整个后移动m 个偏移量
    - 坏字符在模式串中存在一个，将模式串中的坏字符和主串坏字符对齐。
    - 坏字符在模式串中存在多个，将模式串中的最靠后的坏字符与主串对齐
 - 偏移对齐坏字符。
 
通过坏字符的比较，整体效率是非常高的：最好的时间复杂度可以达到O(n/m),但是坏字符存在局限性。比如说ccccc和acc
这个字符比较，就会出现一种现象在将坏字符对齐的时候，你会发现坏字符的位置比 模式串的坏字符位子要小，两者进行位移
计算的时候容易导致一个现象，模式串向后退。此时就要引入好后缀了。

好后缀是什么呢，举个上面说的例子ccccc 和 accc来说。模式串与主串中相同的部分我们称为好后缀，就是公共
部分ccc，那么把这块看成一个整体{ccc}，
 
 - 查找是否还存在好后缀，如果还存在，将好后缀进行对齐
 - 如果不存在其他的好后缀，检查好后缀的尾 和len（模式串的头）是否存在对应
    - 不存在对应直接将模式串后移m个位
    - 如果存在直接将模式串移动到头尾对齐位置。
    
如何选择坏字符和坏后缀进行数据处理。我们可以分别计算好后缀和坏字符移动的位数，然后进行移动，可以避免坏字符移动负数的
情况。


### KMP 算法
其实kmp 算法其实不太好理解，网上博文一大片还是理解起来比较生涩。KMP算法核心无非是在已经比较过的值上面加大一下
步长。

#### 核心原理
kmp核心原理：在对已经比较过的值上进行加大步长的操作，如何跳，跳多少？就是随之而来的问题了。PMT （Partial Match Table
中文翻译为部分比较表。pmt就是解决如何跳、跳多少的一个问题的关键算法。其中核心就是
````
步长 = 已经匹配的个数- 未匹配部分的第一位pmt值
````
举例：主串：abcaccabc，模式串：cab
-  abc 和cab 对比，a和c不相同，模式串后移一位，
- bca和cab 对比，b和c不相同，模式串后移一位
- cac和cab 对比，ca属于相同部分，上面公式已经匹配个数为2，未匹配的部分第一位就是b的pmt值为 0，整体后移2-0 
- cca 和cab 对比，c相同，c和a不同，a的pmt值为0，整体后移1-0
- cab 和cab 对比，相同则返回。

#### pmt值算法
在具体实现kmp算法上都有一个数组是比较难以理解的，在每个算法书中都各有不同，一般成为next数组，在实际编码过程中可能
会把数组整体后移一位在计算完成加上，都是为了方便编码，大家只要知道就是这个pmt组成的数组就行了
- 前缀 ：除了字符串最后一位，都属于前缀
- 后缀：除了字符串第一位都属于后缀

计算 abca的每个值的pmt值

- a 的pmt ：0，因为a的前缀后缀都为空，交集为空
- b 的pmt : 0，实际计算的是ab ,总共存在前缀a， 后缀b,交集为空
- c 的pmt ：0，实际计算abc, 总共存在前缀：a,ab 后缀，c,bc,交集为空 
- d 的pmt : 1,实际计算abca,前缀：a,ab,abc, 后缀： a,ca,bca ，交集为 a

#### AC自动机
在上面的算法中其实都有一个问题，就是基于但模式串匹配，一旦衍生成为多模式串匹配，不论bf、rk、bm、kmp 都是行不通的。比如
敏感词过滤这样一个功能，敏感词很多，但是你总不能用敏感词来对用户发文每次都进行一下匹配吧。那么有什么样的方法来进行多模式串
匹配呢。

说实在话，ac自动机是一个深沉的话题，有时候也会把我自己绕晕，我觉得最好的方式就是你自己模拟构建一套ac自动机的构建和查找过程
整体来说ac自动机和kmp算法还是很相似，最最主要的就是它的fail指针的指向。

##### 核心原理
整体来说其实只要理解了trie树和kmp算法，整个ac自动机是不难的，我就简单说一下原理吧。关于ac自动机，数据结构在trie树上加了一层
fail指针，那么fail指针是什么呢： 如果 i.fail =j ,那么说明root节点到j的组合是root节点到i的最大公共后缀。理解这一点你就理解
了ac自动机了。

- 每个节点都存在一个节点标识：表示当前节点是一个单词组合
- 每个节点的单词标识最好为一个数组，当如果这个值没有的时候就是不算单词，如果有一个或者多个表示这个root到当前节点
是存在一个或者多个单词
- fail指针是每个节点都存在的
- 当节点没有后缀的时候那么就指向root节点
- 构建fail指针的时候需要广度优先遍历trie树
- 每次构建当前节点的fail指针的时候需要查到fafail的指向，然后判断fafail指向节点是否存在当前节点值x，如果存在当前节点fail指针
指向fafail节点的同值节点。

上面就是ac自动机构建trie树+ fail指针的所有逻辑，接下来看看查找逻辑

- 所有查找都从root的子节点开始匹配，没有匹配到的和bf算法一样后移一位进行匹配
- 当开始存在节点的时候，开始找直到存在节点标识。
- 当找到一个节点标识后继续到fail指针上进行查找接下来的匹配，同理