# cluster 
cluster 是什么，从程序角度看来就是集群，之前不是有说redis的集群吗？ 主写从读，这不是redis的集群吗，那么为什么
还有一个cluster。首先我们了解一下之前的结构的缺点，也就是不能满足新的业务需求的点。

假设有一个这样的场景，我需要将50个g的内容存入redis，并且对这50个g的内容提供高速读写服务。那么此时怎么办？
用redis 的主从节点，之前讲过redis 的fork 函数，其实这是系统的fork函数，fork函数是一个阻塞操作，需要拷贝
父进程的内存到子进程中，然后将父子进程通过虚拟地址映射到相同的一份数据上。那么此时我们需要拷贝的内容就是非常大的
，那么阻塞时间是非常长的，对于我们需求的高速读写是非常不友好的。而且在这个过程中频繁的出发bgsave那么整个业务都可能
陷入难以使用的地步。

好，讲回我们的cluster，cluster出来就是为了解决这类问题的实现的。那么就能引出我们这篇文章的目录了

## 目录
- [数据放在哪里](###数据放在哪里)
    - [首先理解数据怎么放入槽的](###首先理解数据怎么放入槽的)
    - [槽是如何分布到redis机器上的](###槽是如何分布到redis机器上的)
- [客户端该怎么做](###客户端该怎么做)
    - [节点的增减客户端如何感知](###节点的增减客户端如何感知)
    - [第一种情况：MOVED](###第一种情况：MOVED)
    - [第二种情况：ASK](###第二种情况：ASK)
    - [建议做法](###建议做法)
       


### 数据放在哪里
其实cluster 原理就是分布式的开发中较为基础的解决方案。具体来说，redis cluster 直接采用的哈希槽，简称slot来处理
数据和机器之间的问题。简单理解就是 一个机器放多个hash槽 ，一个槽放多个数据。

#### 首先理解数据怎么放入槽的
首先根据key 按照crc16 算法获得一个16位的数 在和16384取模 可以获得0~16383的一个范围值，好！此时我们就确认了一个点
了，就是这个key对应的槽了。但是可能你突然有不理解了，我怎么知道槽在哪个redis上呢。

#### 槽是如何分布到redis机器上的
我们可以使用两种命令来控制槽的分布
- cluster create ： 均匀分布槽到对应机器上，
- cluster meet ：加入集群，手动分配槽：注意槽要分配满16384，不然运行就会出错

好了这就是数据的分布，你大概知道了某个key 在某个机器上了，但是就有一个疑问了，你是知道了但是我总不至于要知道所有的key
在哪个地方吧。客户端怎么做呢

### 客户端该怎么做
一般来说的逻辑客户端应该知道在和cluster 建立连接后，cluster 要把哈希槽分配情况发送给客户端：比如说 
- 总共有几台机器，分配每个机器的有哪些槽。

但是有一个有趣的现象，你访问任意一个实例都可以获得其他槽的信息，这是什么原理？redis实例会把自己的哈希槽的分配情况发送给
其他机器，来进行信息扩散，原理和sentinel 互相连接类似。所以客户端在获取到key的时候就可以先计算键值对所在的hash槽，然后给
对应的实例发送请求。

#### 节点的增减客户端如何感知
- 在集群中存在实例有新增删除 ，redis需要从新平衡slot
- 为了负载，需要把所有槽从新分配一遍。

因为实例之间是通过互相传递信息，但是客户端是一个局外人，那么如何知道最新的槽分配情况呢。
#####  第一种情况：MOVED

redis提供了一个重定向相关的解决方案比如：我访问某个key 
````
get demo:demo

(error) MOVED IP:PORT
````
这个表示某个key 迁移到了另外一个机器上了，客户端则要做好这个槽迁移的情况，或者说整体更新一遍本地缓存


##### 第二种情况：ASK

第二种情况是我们访问到某个key 此时这个报错
````
(error) ASK 100 IP:PORT
````
这种情况表明当前这个槽正在迁移，但是呢，这个key还没有迁走，一般不接受打扰，你如果要继续获取这个key的话，那么
就要 调用ASKING的命令

##### 建议做法
因为哈希槽迁移的情况还是比较少的，只存在增加机器的时候，也不会老是去重新分配slot 。那么在这个过程中我们改怎么来
处理呢。建议在中间件中做精细化的订做。对MOVED、ASK报错进行再次请求，不要影响业务层的相关内容。


